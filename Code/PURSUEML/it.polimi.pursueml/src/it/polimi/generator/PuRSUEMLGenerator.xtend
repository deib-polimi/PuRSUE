/*
 * generated by Xtext 2.14.0
 */
package it.polimi.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.*
import it.polimi.pursueml.PuRSUEML
import it.polimi.pursueml.Regola
import it.polimi.pursueml.Sequence
import it.polimi.pursueml.Pdi
import it.polimi.pursueml.Stato
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 
 
 //used to modify strings in the code without printing them
  class strin{
 	public String ga;
 	def void update(String str){
 		this.ga = str;
 		
 	}
 	def boolean is_equal(String str){
 		return this.ga.equals(str)
 	}
 	
 	new(String str){
 		this.ga = str;
 	}
 }
 
 
 	
 class ruler{
 	public List<rule> regole;
 		
 	new(){
 		this.regole = new ArrayList<rule>();
 	}
 		
 		
 	def int indice(String rule_name){
 		var i = 0;
 		var flag = false;
 		if (this.regole.isEmpty())
 			return -1;
 				
 		while (i< this.regole.size() && !flag){
 			if(this.regole.get(i).nome_regola==rule_name){
 				flag = true;
 				}
 			else
 				i++;
 		}
 		if (flag){
 			return i;
 		}
 		else{
 			return -1;
 		}
 	}
 		
 		
 		def List<List<String>> action_blocks(String action){

 			var List<List<String>> guardia = new ArrayList<List<String>>;
 			for (reg : regole){
 				var List<String> guardiola= new ArrayList<String>;
 				for (stat :reg.lista_stati ){
 					if(stat.is_there(action)) //aggiungo una stringa lla guardiola per ogni volta che l'azione c'è nella regola
 					guardiola.add('P'+reg.nome_regola+'=='+reg.lista_stati.indexOf(stat));//non uso la mia funzione indicie visto che sto ciclando e ho in mano l'oggetto propri
 				}
 				if (!guardiola.isEmpty)
 					guardia.add(guardiola);
 				
 			}
 			return guardia;
 			
 			
 		}
 		
 		def boolean are_there_blocks(String action){
 			var temp = action_blocks(action);
 			if (temp.isEmpty) {return false;}
 			else {return true;}
 		}
 		
 				
 		//aggiunto il void
 		def void add_rule(String name){
 			//the method assumes the user didn't define rules with the same name
 			var rule nuovo = new rule (name);
 			regole.add(nuovo);	
 		}
 		
 		def void add_state_at_rule( String state_name, String rule_name){
 			if(this.indice(rule_name)!= -1)
 				this.regole.get(this.indice(rule_name)).add_state(state_name);
 		}
 			
 		
 		def void add_action_at_state_at_rule(String action_name, String state_name, String rule_name){
 			if(this.indice(rule_name)!= -1)
 				this.regole.get(this.indice(rule_name)).add_action_at(action_name, state_name);
 		}
 		
 		def print_ruler()'''
 		«IF !regole.isEmpty()»
 		«FOR rule:regole»
 		«rule.print_rule»
 		«ENDFOR»
 		«ENDIF»
 		'''
 		
 		
 	}
 	
 	class rule{
 		//ogni stato è associato al numero che gli viene assegnato in lista per poi fare il check di posizione
 		public List<state> lista_stati;
 		public String nome_regola;
 		

 		
 		new(String name){
 			this.lista_stati = new ArrayList<state>();	
 			this.nome_regola = name;
 		}
 		
 		def int indice(String state_name){
 			var i = 0;
 			var flag = false;
 			if (this.lista_stati.isEmpty())
 				return -1;
 				
 			while (i< this.lista_stati.size() && !flag){
 				if(this.lista_stati.get(i).ID==state_name)
 					flag = true
 				else
 					i++;
 			}
 			if (flag){
 				return i;
 			}
 			else{
 				return -1;
 			}
 			
 			
 		}
 		
 		def add_state(String nuovo){
 			//il metodo controlla automaticamente se lo stato è già resente e non permette duplicati
 			var int i = 0;
 			var boolean flag = true;
 			while(i <this.lista_stati.size()){
 				if (this.lista_stati.get(i).ID == nuovo)
 					flag = false;
 				i++;
 			}
 			if (flag){
 			var state stato = new state(nuovo);
 			this.lista_stati.add(stato);
 			}
 		}
 		
 		def void add_action_at(String action_name, String state_name){
 			//ci pensa add_Action di state a controllare che non ci siano doppioni, lui controlla che lo stato esista
 			 if (this.indice(state_name)!= -1)
 			this.lista_stati.get(this.indice(state_name)).add_action(action_name);
 		}
 		
 		def print_rule()'''
 		stati in«nome_regola»:
 		«IF !lista_stati.isEmpty()»
 			«FOR state: lista_stati»
 		«state.print_state()»
 			«ENDFOR»
 		«ENDIF»
 		'''
 		
 	}
 	
 	class state{
 		public set_of_actions azioni_permesse;
 		public String ID;
 		
 		new(String name){
 			this.azioni_permesse = new set_of_actions;	
 			this.ID = name;
 		} 		
 		def add_action(String action){
 			//il metodo controllora che l'azione non cisia già
  			var int i = 0;
 			var boolean flag = true;
 			while(i <this.azioni_permesse.size()){
 				if (this.azioni_permesse.is_there(action))
 					flag = false;
 				i++;
 			}
 			if (flag){
 			this.azioni_permesse.add_action(action);
 			}
 			
 		}
 		def boolean isEmpty(){
 			return azioni_permesse.isEmpty();
 		}
 
 			
 		def CharSequence print_state()'''
 		azioni in «ID»:«azioni_permesse.print_all()»
 		'''
 		
 		def boolean is_there(String str){
 			return azioni_permesse.is_there(str);
 		}
 	}
 	
 
 	class set_of_actions{//usata sia per la pura lista di azioni che per il print
 	public List<String> lista_azioni;
 	
 	public LinkedList<String> lista_linkata; 


 	new (){
 		 this.lista_azioni = new ArrayList();
 		 this.lista_linkata = new LinkedList();
 	}
 	
 	def void add_action(String act){
 		this.lista_azioni.add(act);
 	}

 	def boolean is_there(String act){
 		return this.lista_azioni.contains(act);
 	}

 	
 	def void make_linkata(){
 		this.lista_linkata.addAll(lista_azioni);
 	}
 	def int size(){
 		return lista_azioni.size;
 	}


 	def boolean isEmpty(){
 		return lista_azioni.isEmpty();
 	}
 	def print_all()'''
 	«IF !lista_azioni.isEmpty()» azioni:«FOR action : lista_azioni SEPARATOR", "»«action»«ENDFOR»«ENDIF»
 	'''
 	
 }

 
 
 
class PuRSUEMLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile('TGA.xml', SDLtoUPPAAL(resource.contents.head as PuRSUEML))
		fsa.generateFile('TCTL.q', SDLtoQ(resource.contents.head as PuRSUEML))
	}





//nota generale: c'è inconsistenza nel come si fanno i nomi (a volte uso «sdfsd+'s'+ff, a volte chiudo le virgolette, in liena dimassima d'ora in poi cerco di usare il + che mi pare più elegante per i songoli nomi di cose e transizioni, mentre lascio spazi se interagiscono
		//quando c'è da scegliere tra location specific e mobile per le posizioni, c'è ambiguità nel caso sia sia location specific che non mobile lui (non sa se usare la location dell'evento o quella di pino), ho scelto di dirgli nel caso di usare quella dell'evento, nel caso pino non fosse li, dovrebbe non creare la connessione e morta li
		def SDLtoQ(PuRSUEML m)'''
		«IF (m.have_obj && m.have_reach_obj)» control : A[not(obj.lose) U (reachObj.win)]«ENDIF»
		«IF (m.have_obj && !m.have_reach_obj)» control : A[]not(obj.lose)«ENDIF»
		«IF (!m.have_obj && m.have_reach_obj)» control : A<>reachObj.win«ENDIF»
		«IF (!m.have_obj && !m.have_reach_obj)»«ENDIF»
		
		
		
		
		'''
		
		
		def SDLtoUPPAAL(PuRSUEML m) '''
		«var ruler le_regole = new ruler»
			<nta>
			<declaration>
			//events
			«IF !m.connections.isEmpty() &&  !m.agents.filter[mobile].isEmpty() »
			//movements 
			broadcast chan «FOR ag : m.agents.filter[mobile] SEPARATOR', '»« FOR connect: m.connections SEPARATOR ', '»«ag.name+'_'+connect.pdi1.name+'2'+connect.pdi2.name», «ag.name+'_'+connect.pdi2.name+'2'+connect.pdi1.name»«ENDFOR»«ENDFOR» ;
			«ENDIF»
			//actions
			broadcast chan «FOR act : m.events SEPARATOR ', '»«act.name»«IF act.has_duration», «act.name»DONE «ENDIF»«ENDFOR»;
			
			//assuzione che initial state per ogni rule è sempre a index zero quandi si crea, dovrebbe essere coso
			//nota concettuale importante: mentre per le posizioni uso come sono ordinate nella definizione, erl e regole uso come le ordino io nel crearle
			«IF !m.regole.isEmpty()»
			int «FOR rule : m.regole SEPARATOR ', '»P«rule.name»=0«ENDFOR»;
			«ENDIF»	
			//Agents
			//nota: rule and agents can't have the same name
			clock «FOR ag : m.agents SEPARATOR ', '»C«ag.name»«ENDFOR»;
			//tutte le volta che si prendono gli indici delle location, si shiftano di uno, così no c'è la location zero, e quindi non c'è nemmeno lo stato -0 che manda tutto in merda
			int «FOR ag : m.agents SEPARATOR ', '»P«ag.name»=«m.locations.indexOf(ag.initial_location)+1»«ENDFOR»;
			«IF !m.stati.isEmpty()»
			int «FOR st : m.stati SEPARATOR ', '»S«st.name»=«IF st.tr»1«ENDIF»«IF st.fl»0«ENDIF»«ENDFOR»;
			«ENDIF»
			//Objective
			
			«IF m.have_reach_obj»clock Creach;«ENDIF»
			«IF m.have_obj»clock Cobj;«ENDIF»
			</declaration>
			 
			 
			 
			 
			automata_declaration
			«IF !m.stati.isEmpty()»
			state_updater
			<template>
			<name>states</name>
			<location id="base">
			<name>base</name>
			</location>
			<init ref = "base"/>	
			«FOR st: m.stati»
			«FOR ev: st.true_events»
			<transition>
			<source ref="base"/>
			<target ref="base"/>
			<label kind="synchronisation">«ev.name+'?'»</label>
			<label kind="assignment">«'S'+st.name»=1</label>
			</transition>
			«ENDFOR»
			«FOR ev: st.false_events»
			<transition>
			<source ref="base"/>
			<target ref="base"/>
			<label kind="synchronisation">«ev.name+'?'»</label>
			<label kind="assignment">«'S'+st.name»=0</label>
			</transition>
			«ENDFOR»
			«ENDFOR»
			</template>
			«ENDIF»
			
			rules
			«FOR rule: m.regole»
			«le_regole.add_rule(rule.name) »
				
	
						
			<template>
			<name>«rule.name»</name>
			//states declarions
			«print_rule_states(rule, le_regole)»
			<init ref = "«rule.name+'_initial_location'»"/>	
			//transitions
			«print_rule_transitions(rule, le_regole)»
			</template>
			«ENDFOR»
		agents
			«FOR ag : m.agents»
			<template>
			<name>«ag.name»</name>
			 
			//no local declarations used
			 
			//LOCATIONS
			//nota: sto dando stesso ID a location su agneti diversi, spero non lo mandi a male
			//se lo user non definisce connesssioni tra tutte le location lui non smatta
				«IF ag.mobile»
					«FOR loc : m.locations»
			<location id="«loc.name»"> 
			<name>«loc.name»</name>
			</location>
					«ENDFOR»
					
			//transitional locations
					«FOR connect : m.connections»
			<location id="«'going_'+connect.pdi1.name+'_to_'+connect.pdi2.name»">
			<name>«'going_'+connect.pdi1.name+'_to_'+connect.pdi2.name»</name>
			<label kind="invariant">«'C'+ag.name»&lt;=«connect.distance*ag.speed+1»</label>
			</location>
			<location id="«'going_'+connect.pdi2.name+'_to_'+connect.pdi1.name»"> 
			<name>«'going_'+connect.pdi2.name+'_to_'+connect.pdi1.name»</name>			
			<label kind="invariant">«'C'+ag.name»&lt;=«connect.distance*ag.speed+1»</label>
			</location>
			 
					«ENDFOR»
				«ENDIF»
				«IF !ag.mobile»
			<location id = "«ag.initial_location.name»">
			<name>«ag.initial_location.name»</name>
			</location>
			 
				«ENDIF»
				
			//location for durable actions (just one if it's locations specic and/or the agent isn't mobile )
				«FOR act : ag.actions»
					«IF act.has_duration»
						«IF (act.location_specific) »
			<location id = "«'doing_'+act.name+'_in_'+act.location.name»">
			<name>«'doing_'+act.name+'_in_'+act.location.name»</name>
			<label kind="invariant">«'C'+ag.name»&lt;=«act.duration+1»</label>
			</location>
						«ENDIF»
						«IF (!act.location_specific && !ag.mobile ) »
			<location id = "«'doing_'+act.name+'_in_'+ag.initial_location.name»">
			<name>«'doing_'+act.name+'_in_'+ag.initial_location.name»</name>
			<label kind="invariant">«'C'+ag.name»&lt;=«act.duration+1»</label>
			</location>
						«ENDIF»
						«IF (!act.location_specific && ag.mobile)»
							«FOR loc : m.locations»
			<location id = "«'doing_'+act.name+'_in_'+loc.name»">
			<name>«'doing_'+act.name+'_in_'+loc.name»</name>
			<label kind="invariant">«'C'+ag.name» &lt;= «act.duration+1»</label>
			</location>
							«ENDFOR»
						«ENDIF»
						
					«ENDIF»
				«ENDFOR»
							
				
				
				
			//initial location id is passed
			<init ref = "«ag.initial_location.name»"/>	
			
			
			
			
			//transitions
			//movement transitions
				«IF ag.mobile»
					«FOR connect : m.connections»
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«connect.pdi1.name»"/>
			<target ref="«'going_'+connect.pdi1.name+'_to_'+connect.pdi2.name»"/>
			<label kind="synchronisation">«ag.name+'_'+connect.pdi1.name+'2'+connect.pdi2.name+'!'»</label>
			<label kind="guard">«'C'+ag.name» &gt; 1</label>
			<label kind="assignment">«'P'+ag.name» = «'-'+(m.locations.indexOf(connect.pdi1)+1)+(m.locations.indexOf(connect.pdi2)+1)»,  «'C'+ag.name»= 0</label>
			</transition>
			 
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«'going_'+connect.pdi1.name+'_to_'+connect.pdi2.name»"/>
			<target ref="«connect.pdi2.name»"/>
			<label kind="guard">«'C'+ag.name» &gt; «connect.distance*ag.speed»</label>
			<label kind="assignment">«'P'+ag.name» = «(m.locations.indexOf(connect.pdi2)+1)»,  «'C'+ag.name»= 0</label>
			</transition>
			 
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«connect.pdi2.name»"/>
			<target ref="«'going_'+connect.pdi2.name+'_to_'+connect.pdi1.name»"/>
			<label kind="synchronisation">«ag.name+'_'+connect.pdi2.name+'2'+connect.pdi1.name+'!'»</label>
			<label kind="guard">«'C'+ag.name» &gt; 1</label>
			<label kind="assignment"> «'P'+ag.name» = «'-'+ (m.locations.indexOf(connect.pdi2)+1)+(m.locations.indexOf(connect.pdi1)+1)»,  «'C'+ag.name»= 0</label>
			</transition>
			 
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«'going_'+connect.pdi2.name+'_to_'+connect.pdi1.name»"/>
			<target ref="«connect.pdi1.name»"/>
			<label kind="guard">«'C'+ag.name»&gt;«connect.distance*ag.speed»</label>
			<label kind="assignment">«'P'+ag.name» = «(m.locations.indexOf(connect.pdi1)+1)»,  «'C'+ag.name»= 0</label>
			</transition>
					«ENDFOR»
				«ENDIF»
				
			//action transitions
			//BUG : if an action si collaborative but nobody can react to it, the action will be always allowed
			
				«FOR act : ag.actions»
					«IF (act.location_specific)»
						«IF(act.has_duration)»
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«act.location.name»"/>
			<target ref="«'doing_'+act.name+'_in_'+act.location.name»"/>
			<label kind="synchronisation">«act.name+'!'»</label>
			<label kind="assignment"> «'C'+ag.name» =0,«'P'+ag.name»=«'-'+(m.locations.indexOf(act.location)+1)+(m.locations.indexOf(act.location)+1)» </label>
			<label kind="guard">«'C'+ag.name» &gt; 1«IF act.collaborative» &amp;&amp; («FOR collaborator :m.agents.filter[reactions.contains(act)] SEPARATOR' || '»«'P'+collaborator.name+'=='+(m.locations.indexOf(act.location)+1)»«ENDFOR») «ENDIF»«IF(le_regole.are_there_blocks(act.name))» &amp;&amp; «ENDIF»  «FOR block: le_regole.action_blocks(act.name) SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»«FOR dip : m.dipendenze.filter[evento==act]»«IF dip.tr»«"&amp;&amp; "+'S'+dip.stat.name+'==1'»«ENDIF»«IF dip.fl»«" &amp;&amp; "+'S'+dip.stat.name+'==0'»«ENDIF»«ENDFOR»</label>
			</transition>
			 
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«'doing_'+act.name+'_in_'+act.location.name»"/>
			<target ref="«act.location.name»"/>
			<label kind="synchronisation">«act.name+'DONE'+'!'»</label>
			<label kind="assignment"> «'C'+ag.name» =0, «'P'+ag.name»=«(m.locations.indexOf(act.location)+1)» </label>
			<label kind="guard"> «'C'+ag.name» &gt; «act.duration»«IF(le_regole.are_there_blocks(act.name+'DONE'))» &amp;&amp; «ENDIF» «FOR block: le_regole.action_blocks(act.name+'DONE') SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»</label>
			</transition>			
			 
						«ENDIF»
						«IF(!act.has_duration)»
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«act.location.name»"/>
			<target ref="«act.location.name»"/>
			<label kind="synchronisation">«act.name+'!'»</label>
			<label kind="assignment"> «'C'+ag.name» =0 </label>
			<label kind="guard">«'C'+ag.name» &gt; 1«IF act.collaborative» &amp;&amp; («FOR collaborator :m.agents.filter[reactions.contains(act)] SEPARATOR' || '»«'P'+collaborator.name+'=='+(m.locations.indexOf(act.location)+1)»«ENDFOR»)«ENDIF»«IF(le_regole.are_there_blocks(act.name))» &amp;&amp; «ENDIF» «FOR block: le_regole.action_blocks(act.name) SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»«FOR dip : m.dipendenze.filter[evento==act]»«IF dip.tr»«"&amp;&amp; "+'S'+dip.stat.name+'==1'»«ENDIF»«IF dip.fl»«" &amp;&amp; "+'S'+dip.stat.name+'==0'»«ENDIF»«ENDFOR»</label>
			</transition>
			 
			 			«ENDIF»
			 		«ENDIF»
					«IF (!act.location_specific && !ag.mobile) »
						«IF(act.has_duration)»
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«ag.initial_location.name»"/>
			<target ref="«'doing_'+act.name+'_in_'+ag.initial_location.name»"/>
			<label kind="synchronisation">«act.name+'!'»</label>
			<label kind="assignment">«'C'+ag.name» =0,«'P'+ag.name»=«'-'+(m.locations.indexOf(ag.initial_location)+1)+(m.locations.indexOf(ag.initial_location)+1)»</label>
			<label kind="guard">«'C'+ag.name» &gt; 1«IF act.collaborative» &amp;&amp; («FOR collaborator :m.agents.filter[reactions.contains(act)] SEPARATOR' || '»«'P'+collaborator.name+'=='+(m.locations.indexOf(ag.initial_location)+1)»«ENDFOR»)«ENDIF»«IF(le_regole.are_there_blocks(act.name))» &amp;&amp; «ENDIF»  «FOR block: le_regole.action_blocks(act.name) SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»«FOR dip : m.dipendenze.filter[evento==act]»«IF dip.tr»«"&amp;&amp; "+'S'+dip.stat.name+'==1'»«ENDIF»«IF dip.fl»«" &amp;&amp; "+'S'+dip.stat.name+'==0'»«ENDIF»«ENDFOR»</label>
			</transition>
			 
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«'doing_'+act.name+'_in_'+ag.initial_location.name»"/>
			<target ref="«ag.initial_location.name»"/>
			<label kind="synchronisation">«act.name+'DONE'+'!'»</label>
			<label kind="assignment"> «'C'+ag.name» =0,«'P'+ag.name»=«(m.locations.indexOf(ag.initial_location)+1)»  </label>
			<label kind="guard"> «'C'+ag.name» &gt; «act.duration»«IF(le_regole.are_there_blocks(act.name+'DONE'))» &amp;&amp; «ENDIF» «FOR block: le_regole.action_blocks(act.name+'DONE') SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»</label>
			</transition>			
			 
						«ENDIF»
		
						«IF(!act.has_duration)»
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«ag.initial_location.name»"/>
			<target ref="«ag.initial_location.name»"/>
			<label kind="synchronisation">«act.name+'!'»</label>
			<label kind="assignment"> «'C'+ag.name» =0 </label>
			<label kind="guard">«'C'+ag.name» &gt; 1«IF act.collaborative» &amp;&amp; («FOR collaborator :m.agents.filter[reactions.contains(act)] SEPARATOR' || '»«'P'+collaborator.name+'=='+(m.locations.indexOf(ag.initial_location)+1)»«ENDFOR»)«ENDIF»«IF(le_regole.are_there_blocks(act.name))» &amp;&amp; «ENDIF» «FOR block: le_regole.action_blocks(act.name) SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»«FOR dip : m.dipendenze.filter[evento==act]»«IF dip.tr»«"&amp;&amp; "+'S'+dip.stat.name+'==1'»«ENDIF»«IF dip.fl»«" &amp;&amp; "+'S'+dip.stat.name+'==0'»«ENDIF»«ENDFOR»</label>
			</transition>
			 		
						«ENDIF»
					«ENDIF»
		
					«IF (!act.location_specific && ag.mobile)»
						«FOR loc : m.locations»
							«IF(act.has_duration)»
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«loc.name»"/>
			<target ref="«'doing_'+act.name+'_in_'+loc.name»"/>
			<label kind="synchronisation">«act.name+'!'»</label>
			<label kind="assignment">«'C'+ag.name» =0,«'P'+ag.name»=«'-'+(m.locations.indexOf(loc)+1)+(m.locations.indexOf(loc)+1)» </label>
			<label kind="guard">«'C'+ag.name» &gt; 1«IF act.collaborative» &amp;&amp; («FOR collaborator :m.agents.filter[reactions.contains(act)] SEPARATOR' || '»«'P'+collaborator.name+'=='+(m.locations.indexOf(loc)+1)»«ENDFOR») «ENDIF»«IF(le_regole.are_there_blocks(act.name))» &amp;&amp; «ENDIF» «FOR block: le_regole.action_blocks(act.name) SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»«FOR dip : m.dipendenze.filter[evento==act]»«IF dip.tr»«"&amp;&amp; "+'S'+dip.stat.name+'==1'»«ENDIF»«IF dip.fl»«" &amp;&amp; "+'S'+dip.stat.name+'==0'»«ENDIF»«ENDFOR»</label>
			</transition>
			 
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«'doing_'+act.name+'_in_'+loc.name»"/>
			<target ref="«loc.name»"/>
			<label kind="synchronisation">«act.name+'DONE'+'!'»</label>
			<label kind="assignment"> «'C'+ag.name» =0, «'P'+ag.name»=«(m.locations.indexOf(loc)+1)» </label>
			<label kind="guard"> «'C'+ag.name» &gt; «act.duration»«IF(le_regole.are_there_blocks(act.name+'DONE'))» &amp;&amp; «ENDIF» «FOR block: le_regole.action_blocks(act.name+'DONE') SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»</label>
			</transition>			
			 
							«ENDIF»

							«IF(!act.has_duration)»
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«loc.name»"/>
			<target ref="«loc.name»"/>
			<label kind="synchronisation">«act.name+'!'»</label>
			<label kind="assignment"> «'C'+ag.name» =0 </label>
			<label kind="guard">«'C'+ag.name» &gt; 1«IF act.collaborative» &amp;&amp; («FOR collaborator :m.agents.filter[reactions.contains(act)] SEPARATOR' || '»«'P'+collaborator.name+'=='+(m.locations.indexOf(loc)+1)»«ENDFOR»)«ENDIF»«IF(le_regole.are_there_blocks(act.name))» &amp;&amp; «ENDIF»  «FOR block: le_regole.action_blocks(act.name) SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»«FOR dip : m.dipendenze.filter[evento==act]»«IF dip.tr»«"&amp;&amp; "+'S'+dip.stat.name+'==1'»«ENDIF»«IF dip.fl»«" &amp;&amp; "+'S'+dip.stat.name+'==0'»«ENDIF»«ENDFOR»</label>
			</transition>
			 
			 				«ENDIF»
			 			«ENDFOR»
			 			«FOR con: m.connections»
			 				«IF(!act.has_duration)»
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«'going_'+con.pdi1.name+'_to_'+con.pdi2.name»"/>
			<target ref="«'going_'+con.pdi1.name+'_to_'+con.pdi2.name»"/>
			<label kind="synchronisation">«act.name+'!'»</label>
			<label kind="guard">«'C'+ag.name» &gt; 0«IF act.collaborative» &amp;&amp; («FOR collaborator :m.agents.filter[reactions.contains(act)] SEPARATOR' || '»«'P'+collaborator.name+'=='+'-'+(m.locations.indexOf(con.pdi2)+1)+(m.locations.indexOf(con.pdi1)+1)»«ENDFOR»)«ENDIF»«IF(le_regole.are_there_blocks(act.name))» &amp;&amp; «ENDIF»  «FOR block: le_regole.action_blocks(act.name) SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»«FOR dip : m.dipendenze.filter[evento==act]»«IF dip.tr»«"&amp;&amp; "+'S'+dip.stat.name+'==1'»«ENDIF»«IF dip.fl»«" &amp;&amp; "+'S'+dip.stat.name+'==0'»«ENDIF»«ENDFOR»</label>
			</transition>
			
			<transition«IF !ag.controllable» controllable="false" «ENDIF»>
			<source ref="«'going_'+con.pdi2.name+'_to_'+con.pdi1.name»"/>
			<target ref="«'going_'+con.pdi2.name+'_to_'+con.pdi1.name»"/>
			<label kind="synchronisation">«act.name+'!'»</label>
			<label kind="guard">«'C'+ag.name» &gt; 0«IF act.collaborative» &amp;&amp; («FOR collaborator :m.agents.filter[reactions.contains(act)] SEPARATOR' || '»«'P'+collaborator.name+'=='+'-'+(m.locations.indexOf(con.pdi1)+1)+(m.locations.indexOf(con.pdi2)+1)»«ENDFOR»)«ENDIF»«IF(le_regole.are_there_blocks(act.name))» &amp;&amp; «ENDIF»  «FOR block: le_regole.action_blocks(act.name) SEPARATOR " &amp;&amp; " » ( «FOR rulla : block SEPARATOR " || "»« rulla»«ENDFOR» ) «ENDFOR»«FOR dip : m.dipendenze.filter[evento==act]»«IF dip.tr»«"&amp;&amp; "+'S'+dip.stat.name+'==1'»«ENDIF»«IF dip.fl»«" &amp;&amp; "+'S'+dip.stat.name+'==0'»«ENDIF»«ENDFOR»</label>
			</transition>
			 				«ENDIF»
			 			«ENDFOR»
					«ENDIF»
				«ENDFOR»
							
				
				
				
			</template>		
			 
				
			«ENDFOR»	


		
			
		objectives
		
		«IF m.have_obj»
		<template>
		<name>obj</name>
		
		//locations declaration
		
		<location id = "idle">
		<name>idle</name>
		</location>
		
		<location id = "lose">
		<name>lose</name>
		</location>		
		
			«IF m.objective.is_if»
		<location id = "atRisk">
		<name>atRisk</name>
		<label kind="invariant"> Cobj &lt;= «m.objective.time»</label>
		</location>	
			«ENDIF»
		<init ref = "idle"/>	
			
		//transition declaration
		 
			«IF m.objective.is_if»		
		<transition>
		<source ref="idle"/>
		<target ref="atRisk"/>
				«IF m.objective.cause.has_duration»
		<label kind="synchronisation">«m.objective.cause.name+'DONE'+'?'»</label>
				«ENDIF»
				«IF !m.objective.cause.has_duration»
		<label kind="synchronisation">«m.objective.cause.name+'?'»</label>
				«ENDIF»
		<label kind = "assignment">Cobj = 0</label>
		</transition>
		
		<transition>
		<source ref="atRisk"/>
		<target ref="idle"/>
				«IF m.objective.reaction.has_duration»
		<label kind="synchronisation">«m.objective.reaction.name+'DONE'+'?'»</label>
				«ENDIF»
				«IF !m.objective.reaction.has_duration»
		<label kind="synchronisation">«m.objective.reaction.name+'?'»</label>
				«ENDIF»
		</transition>				
		<transition>
		<source ref="atRisk"/>
		<target ref="lose"/>
		</transition>				
			«ENDIF»
			«IF m.objective.is_avoid»					
		<transition>
		<source ref="idle"/>
		<target ref="lose"/>
				«IF m.objective.lose.has_duration»
		<label kind="synchronisation">«m.objective.lose.name+'DONE'+'?'»</label>
				«ENDIF»
				«IF !m.objective.lose.has_duration»
		<label kind="synchronisation">«m.objective.lose.name+'?'»</label>
				«ENDIF»
		</transition>
			«ENDIF»
		</template>
		«ENDIF»
		«IF m.have_reach_obj»
		<template>
		<name>reachObj</name>
		//locations
		
		<location id = "initial_location">
		<name>initial_location</name>
		</location>
		<location id = "unlocked">
		</location>
		<location id = "win">
		<name>win</name>
		</location>
		 
		<init ref = "initial_location"/>	
		 
		//transitions
		<transition>
		<source ref="initial_location"/>
		<target ref="unlocked"/>
		<label kind = "guard">Creach &gt; «m.reachobjective.life_span»</label>
		</transition>	
		
		<transition>
		<source ref="unlocked"/>
		<target ref="win"/>
				«IF m.reachobjective.goal.has_duration»
		<label kind="synchronisation">«m.reachobjective.goal.name+'DONE'+'?'»</label>
				«ENDIF»
				«IF !m.reachobjective.goal.has_duration»
		<label kind="synchronisation">«m.reachobjective.goal.name+'?'»</label>
				«ENDIF»
		</transition>
		
		</template>
		«ENDIF»

			//in questo momento bugga se non ci sono regole
			<system>
			system «IF !m.stati.isEmpty() » states,«ENDIF» «FOR ag : m.agents SEPARATOR ', '»«ag.name»«ENDFOR»«IF m.have_obj», obj«ENDIF»«IF m.have_reach_obj» ,reachObj «ENDIF» «FOR rule : m.regole», «rule.name»«ENDFOR»;
			
			
			
			</system>

			
			</nta>
			'''
	
	def boolean is_location_here(Pdi[] locations, String loc){
		var boolean flag = false;
		return flag;
	}

	def  boolean is_event_here ( Regola r, String event){
		var boolean flag1= false;
		var boolean flag2 = false;
		if (r.is_seq1)
			flag1 = is_event_here_2(r.first_seq, event)
		else
			flag1 = event.equals(r.first_ev.name)
		if (r.is_seq2)
			flag2 = is_event_here_2(r.second_seq, event)
		else
			flag2 = event.equals(r.second_ev.name)
		return flag1 || flag2;
	}
			
	def boolean is_event_here_2(Sequence s, String event){
		var boolean flag1 = false;
		var boolean flag2 = false;
		if (s.is_seq1)
			flag1 = is_event_here_2(s.first_seq, event)
		else
			flag1 = event.equals(s.first_ev.name)
		if (s.is_seq2)
			flag2 = is_event_here_2(s.second_seq, event)
		else
			flag2 = event.equals(s.second_ev.name)
		return flag1 || flag2;
		
	}		
			
			
			
			def print_rule_events (Regola r)'''
		«var azioni_dichiarate = new set_of_actions»
		«IF (r.is_seq1)»
			«print_sequence_events(r, r.first_seq, azioni_dichiarate)»
		«ENDIF»
		«IF (!r.is_seq1 && !azioni_dichiarate.is_there(r.first_ev.name))»
		chan «r.name+'_'+r.first_ev.name»«IF r.first_ev.has_duration», «r.name+'_'+r.first_ev.name+'DONE'»«ENDIF»;
		«azioni_dichiarate.add_action(r.first_ev.name)»
		«ENDIF»	
		«IF (r.is_seq2) »
			«print_sequence_events(r, r.second_seq, azioni_dichiarate)»
		«ENDIF»
		«IF (!r.is_seq2 && !azioni_dichiarate.is_there(r.second_ev.name))»
		chan «r.name+'_'+r.second_ev.name»«IF r.second_ev.has_duration», «r.name+'_'+r.second_ev.name+'DONE'»«ENDIF»;
		«azioni_dichiarate.add_action(r.first_ev.name)»
		«ENDIF»
	'''
			def print_sequence_events(Regola r, Sequence s, set_of_actions azioni_dichiarate)'''
		«IF (s.is_seq1)»
			«print_sequence_events(r, s.first_seq, azioni_dichiarate)»
		«ENDIF»
		«IF (!s.is_seq1 && !azioni_dichiarate.is_there(s.first_ev.name))»
		chan «r.name+'_'+s.first_ev.name»«IF s.first_ev.has_duration», «r.name+'_'+s.first_ev.name+'DONE'»«ENDIF»;
		«azioni_dichiarate.add_action(s.first_ev.name)»
		«ENDIF»
		
		«IF (s.is_seq2)»
			«print_sequence_events(r, s.second_seq, azioni_dichiarate)»
		«ENDIF»
		
		«IF (!s.is_seq2 && !azioni_dichiarate.is_there(s.second_ev.name))»
		chan «r.name+'_'+s.second_ev.name»«IF s.second_ev.has_duration», «r.name+'_'+s.second_ev.name+'DONE'»«ENDIF»;
		«azioni_dichiarate.add_action(s.second_ev.name)»
		«ENDIF»
	'''


			def print_rule_states (Regola r, ruler le_regole)'''
		«var layer = 0»
		<location id="«r.name+'_initial_location'»">
		</location>
		«le_regole.add_state_at_rule(r.name+'_initial_location', r.name)»
		«IF (r.is_seq1)»
			«print_sequence_states(r, r.first_seq, layer, "f",le_regole)»
		«ENDIF»
		«IF (!r.is_seq1 && r.first_ev.has_duration)»
		<location id="«r.name+layer.toString+'f'+'_doing_'+r.first_ev.name»">
		</location>
		«le_regole.add_state_at_rule(r.name+layer.toString+'f'+'_doing_'+r.first_ev.name, r.name)»
		«ENDIF»
		«IF (r.then)»	
		<location id="«r.name+layer»">
		</location>
		«le_regole.add_state_at_rule(r.name+layer, r.name)»
		«ENDIF»
		
		«IF (r.is_seq2) »
			«print_sequence_states(r, r.second_seq, layer, "s",le_regole)»
		«ENDIF»	
		«IF (!r.is_seq2 && r.second_ev.has_duration)»
		<location id="«r.name+layer.toString+'s'+'_doing_'+r.second_ev.name»">
		</location>
		«le_regole.add_state_at_rule(r.name+layer.toString+'s'+'_doing_'+r.second_ev.name, r.name)»
		«ENDIF»
	'''





	def print_sequence_states(Regola r, Sequence s, int layer, String side, ruler le_regole)'''
		«var layer_now = layer+1»
		«IF (s.is_seq1)»
			«print_sequence_states(r, s.first_seq, layer_now, side+"f", le_regole)»
		«ENDIF»
		«IF (!s.is_seq1 && s.first_ev.has_duration)»
		<location id="«r.name+layer_now.toString+side+'_fir_doing_'+s.first_ev.name»">
		</location>
		«le_regole.add_state_at_rule(r.name+layer_now.toString+side+'_fir_doing_'+s.first_ev.name, r.name)»
		«ENDIF»
		
		«IF (s.then)»
		<location id="«r.name+layer_now.toString+side»">
		</location>
		«le_regole.add_state_at_rule(r.name+layer_now.toString+side, r.name)»
		«ENDIF»
		«IF (s.is_seq2) »
			«print_sequence_states(r, s.second_seq, layer_now, side+"s",le_regole)»
		«ENDIF»
		«IF (!s.is_seq2 && s.second_ev.has_duration)»
		<location id="«r.name+layer_now.toString+side+'_sec_doing_'+s.second_ev.name»">
		</location>
		«le_regole.add_state_at_rule(r.name+layer_now.toString+side+'_sec_doing_'+s.second_ev.name, r.name)»
		«ENDIF»
	'''
	
	
	
		def print_rule_transitions (Regola r, ruler le_regole)'''
		«var layer = 0»
		«var last_state =new strin(r.name+"_initial_location")»
		«var next_state = new strin(r.name+"_initial_location")»
		
		«IF r.then»«next_state.update(r.name+layer.toString) »«ENDIF»
		
		«IF (r.is_seq1)»
			«print_sequence_transitions(r, r.first_seq, layer, "f" ,last_state.ga, next_state.ga, le_regole)»
		«ENDIF»
		
		«IF (!r.is_seq1)»
			«IF !r.first_ev.has_duration»
		<transition>
		<source ref="«last_state.ga»"/>
		<target ref="«next_state.ga»"/>
		<label kind="synchronisation">«r.first_ev.name+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(next_state.ga)»</label>
		</transition>			
		«le_regole.add_action_at_state_at_rule(r.first_ev.name, last_state.ga, r.name)»
			«ENDIF»
			«IF r.first_ev.has_duration»
		<transition>
		<source ref="«last_state.ga»"/>
		<target ref="«r.name+layer.toString+'f'+'_doing_'+r.first_ev.name»"/>
		<label kind="synchronisation">«r.first_ev.name+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(r.name+layer.toString+'f'+'_doing_'+r.first_ev.name)»</label>
		</transition>	
		«le_regole.add_action_at_state_at_rule(r.first_ev.name, last_state.ga, r.name)»
		<transition>
		<source ref="«r.name+layer.toString+'f'+'_doing_'+r.first_ev.name»"/>
		<target ref="«next_state.ga»"/>
		<label kind="synchronisation">«r.first_ev.name+'DONE'+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(next_state.ga)»</label>
		</transition>		
		«le_regole.add_action_at_state_at_rule(r.first_ev.name+'DONE', r.name+layer.toString+'f'+'_doing_'+r.first_ev.name, r.name)»	
			«ENDIF»
		«ENDIF»

		«IF (r.then)»	
			«last_state.update(r.name+layer.toString)»
			«next_state.update(r.name+"_initial_location")»
		«ENDIF»

		
		«IF (r.is_seq2) »
			«print_sequence_transitions(r, r.second_seq, layer, "s" ,last_state.ga, next_state.ga, le_regole)»
		«ENDIF»
		«IF (!r.is_seq2)»
			«IF !r.second_ev.has_duration»
		<transition>
		<source ref="«last_state.ga»"/>
		<target ref="«next_state.ga»"/>
		<label kind="synchronisation">«r.second_ev.name+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(next_state.ga)»</label>
		</transition>			
		«le_regole.add_action_at_state_at_rule(r.second_ev.name, last_state.ga, r.name)»
			«ENDIF»
			«IF r.second_ev.has_duration»
		<transition>
		<source ref="«last_state.ga»"/>
		<target ref="«r.name+layer.toString+'s'+'_doing_'+r.second_ev.name»"/>
		<label kind="synchronisation">«r.second_ev.name+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(r.name+layer.toString+'s'+'_doing_'+r.second_ev.name)»</label>
		</transition>	
		«le_regole.add_action_at_state_at_rule(r.second_ev.name, last_state.ga, r.name)»
		<transition>
		<source ref="«r.name+layer.toString+'s'+'_doing_'+r.second_ev.name»"/>
		<target ref="«next_state.ga»"/>
		<label kind="synchronisation">«r.second_ev.name+'DONE'+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(next_state.ga)»</label>
		</transition>	
		«le_regole.add_action_at_state_at_rule(r.second_ev.name+'DONE', r.name+layer.toString+'s'+'_doing_'+r.second_ev.name, r.name)»		
			«ENDIF»
		«ENDIF»
	'''

	def CharSequence print_sequence_transitions(Regola r, Sequence s, int layer, String side, String last_state, String next_state, ruler le_regole)'''
		«var layer_now = layer+1»
		«var next_state_now = new strin(next_state)»
		«var last_state_now = new strin(last_state)»
		
		«IF s.then /*guardo se o un nuovo next */»
			«next_state_now.update(r.name+layer_now.toString+side)»
		«ENDIF»
		
		«IF (s.is_seq1)»
			«print_sequence_transitions(r, s.first_seq, layer_now, side+"f", last_state_now.ga, next_state_now.ga, le_regole)»
		«ENDIF»
		
		«IF (!s.is_seq1)»
			«IF !s.first_ev.has_duration»
		<transition>
		<source ref="«last_state_now.ga»"/>
		<target ref="«next_state_now.ga»"/>
		<label kind="synchronisation">«s.first_ev.name+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(next_state_now.ga)»</label>
		</transition>			
		«le_regole.add_action_at_state_at_rule(s.first_ev.name, last_state_now.ga, r.name)»
			«ENDIF»
			«IF s.first_ev.has_duration»
		<transition>
		<source ref="«last_state_now.ga»"/>
		<target ref="«r.name+layer_now.toString+side+'_fir_doing_'+s.first_ev.name»"/>
		<label kind="synchronisation">«s.first_ev.name+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(r.name+layer_now.toString+side+'_fir_doing_'+s.first_ev.name)»</label>
		</transition>	
		«le_regole.add_action_at_state_at_rule(s.first_ev.name, last_state_now.ga, r.name)»
		<transition>
		<source ref="«r.name+layer_now.toString+side+'_fir_doing_'+s.first_ev.name»"/>
		<target ref="«next_state_now.ga»"/>
		<label kind="synchronisation">«s.first_ev.name+'DONE'+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(next_state_now.ga)»</label>
		</transition>			
		«le_regole.add_action_at_state_at_rule(s.first_ev.name+'DONE', r.name+layer_now.toString+side+'_fir_doing_'+s.first_ev.name, r.name)»
			«ENDIF»
		«ENDIF»
		«IF (s.then)/*aggiorno last state se l'ho connesso ad uno stato locale*/»
			«last_state_now.update(r.name+layer_now.toString+side) »
			«next_state_now.update(next_state)»	
		«ENDIF»
		
		«IF (s.is_seq2) »
			«print_sequence_transitions(r, s.second_seq, layer_now, side+"s", last_state_now.ga, next_state_now.ga, le_regole)»
		«ENDIF»
		«IF (!s.is_seq2)»
			«IF !s.second_ev.has_duration»
		<transition>
		<source ref="«last_state_now.ga»"/>
		<target ref="«next_state_now.ga»"/>
		<label kind="synchronisation">«s.second_ev.name+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(next_state_now.ga)»</label>
		</transition>			
		«le_regole.add_action_at_state_at_rule(s.second_ev.name, last_state_now.ga, r.name)»
			«ENDIF»
			«IF s.second_ev.has_duration»
		<transition>
		<source ref="«last_state_now.ga»"/>
		<target ref="«r.name+layer_now.toString+side+'_sec_doing_'+s.second_ev.name»"/>
		<label kind="synchronisation">«s.second_ev.name+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(r.name+layer_now.toString+side+'_sec_doing_'+s.second_ev.name)»</label>
		</transition>	
		«le_regole.add_action_at_state_at_rule(s.second_ev.name, last_state_now.ga, r.name)»
		<transition>
		<source ref="«r.name+layer_now.toString+side+'_sec_doing_'+s.second_ev.name»"/>
		<target ref="«next_state_now.ga»"/>
		<label kind="synchronisation">«s.second_ev.name+'DONE'+'?'»</label>
		<label kind="assignment">«'P'+r.name» = «le_regole.regole.get(le_regole.indice(r.name)).indice(next_state_now.ga)»</label>
		</transition>			
		«le_regole.add_action_at_state_at_rule(s.second_ev.name+'DONE', r.name+layer_now.toString+side+'_sec_doing_'+s.second_ev.name, r.name)»
			«ENDIF»
		«ENDIF»	
	'''
	
	
	

}
		